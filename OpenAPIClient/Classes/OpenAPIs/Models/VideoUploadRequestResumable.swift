//
// VideoUploadRequestResumable.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct VideoUploadRequestResumable: Codable, JSONEncodable, Hashable {

    static let nameRule = StringRule(minLength: 3, maxLength: 120, pattern: nil)
    static let channelIdRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    /** Video name */
    public var name: String
    /** Channel id that will contain this video */
    public var channelId: Int
    public var privacy: VideoPrivacySet?
    /** category id of the video (see [/videos/categories](#operation/getCategories)) */
    public var category: Int?
    /** licence id of the video (see [/videos/licences](#operation/getLicences)) */
    public var licence: Int?
    /** language id of the video (see [/videos/languages](#operation/getLanguages)) */
    public var language: String?
    /** Video description */
    public var description: String?
    /** Whether or not we wait transcoding before publish the video */
    public var waitTranscoding: Bool?
    /** A text tell the audience how to support the video creator */
    public var support: String?
    /** Whether or not this video contains sensitive content */
    public var nsfw: Bool?
    /** Video tags (maximum 5 tags each between 2 and 30 characters) */
    public var tags: Set<String>?
    /** Enable or disable comments for this video */
    public var commentsEnabled: Bool?
    /** Enable or disable downloading for this video */
    public var downloadEnabled: Bool?
    /** Date when the content was originally published */
    public var originallyPublishedAt: Date?
    public var scheduleUpdate: VideoScheduledUpdate?
    /** Video thumbnail file */
    public var thumbnailfile: URL?
    /** Video preview file */
    public var previewfile: URL?
    public var videoPasswords: Set<String>?
    /** Video filename including extension */
    public var filename: String

    public init(name: String, channelId: Int, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, waitTranscoding: Bool? = nil, support: String? = nil, nsfw: Bool? = nil, tags: Set<String>? = nil, commentsEnabled: Bool? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, videoPasswords: Set<String>? = nil, filename: String) {
        self.name = name
        self.channelId = channelId
        self.privacy = privacy
        self.category = category
        self.licence = licence
        self.language = language
        self.description = description
        self.waitTranscoding = waitTranscoding
        self.support = support
        self.nsfw = nsfw
        self.tags = tags
        self.commentsEnabled = commentsEnabled
        self.downloadEnabled = downloadEnabled
        self.originallyPublishedAt = originallyPublishedAt
        self.scheduleUpdate = scheduleUpdate
        self.thumbnailfile = thumbnailfile
        self.previewfile = previewfile
        self.videoPasswords = videoPasswords
        self.filename = filename
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case name
        case channelId
        case privacy
        case category
        case licence
        case language
        case description
        case waitTranscoding
        case support
        case nsfw
        case tags
        case commentsEnabled
        case downloadEnabled
        case originallyPublishedAt
        case scheduleUpdate
        case thumbnailfile
        case previewfile
        case videoPasswords
        case filename
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(name, forKey: .name)
        try container.encode(channelId, forKey: .channelId)
        try container.encodeIfPresent(privacy, forKey: .privacy)
        try container.encodeIfPresent(category, forKey: .category)
        try container.encodeIfPresent(licence, forKey: .licence)
        try container.encodeIfPresent(language, forKey: .language)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(waitTranscoding, forKey: .waitTranscoding)
        try container.encodeIfPresent(support, forKey: .support)
        try container.encodeIfPresent(nsfw, forKey: .nsfw)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(commentsEnabled, forKey: .commentsEnabled)
        try container.encodeIfPresent(downloadEnabled, forKey: .downloadEnabled)
        try container.encodeIfPresent(originallyPublishedAt, forKey: .originallyPublishedAt)
        try container.encodeIfPresent(scheduleUpdate, forKey: .scheduleUpdate)
        try container.encodeIfPresent(thumbnailfile, forKey: .thumbnailfile)
        try container.encodeIfPresent(previewfile, forKey: .previewfile)
        try container.encodeIfPresent(videoPasswords, forKey: .videoPasswords)
        try container.encode(filename, forKey: .filename)
    }
}

