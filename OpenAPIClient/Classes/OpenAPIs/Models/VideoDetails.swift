//
// VideoDetails.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

public struct VideoDetails: Codable, JSONEncodable, Hashable {

    static let idRule = NumericRule<Int>(minimum: 1, exclusiveMinimum: false, maximum: nil, exclusiveMaximum: false, multipleOf: nil)
    static let uuidRule = StringRule(minLength: 36, maxLength: 36, pattern: "/^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/")
    static let descriptionRule = StringRule(minLength: 3, maxLength: 250, pattern: nil)
    static let nameRule = StringRule(minLength: 3, maxLength: 120, pattern: nil)
    static let supportRule = StringRule(minLength: 3, maxLength: 1000, pattern: nil)
    public var id: Int?
    public var uuid: UUID?
    /** translation of a uuid v4 with a bigger alphabet to have a shorter uuid */
    public var shortUUID: String?
    public var isLive: Bool?
    /** time at which the video object was first drafted */
    public var createdAt: Date?
    /** time at which the video was marked as ready for playback (with restrictions depending on `privacy`). Usually set after a `state` evolution. */
    public var publishedAt: Date?
    /** last time the video's metadata was modified */
    public var updatedAt: Date?
    /** used to represent a date of first publication, prior to the practical publication date of `publishedAt` */
    public var originallyPublishedAt: Date?
    public var category: VideoConstantNumberCategory?
    public var licence: VideoConstantNumberLicence?
    public var language: VideoConstantStringLanguage?
    public var privacy: VideoPrivacyConstant?
    /** truncated description of the video, written in Markdown. Resolve `descriptionPath` to get the full description of maximum `10000` characters.  */
    public var description: String?
    /** duration of the video in seconds */
    public var duration: Int?
    public var isLocal: Bool?
    /** title of the video */
    public var name: String?
    public var thumbnailPath: String?
    public var previewPath: String?
    public var embedPath: String?
    public var views: Int?
    public var likes: Int?
    public var dislikes: Int?
    public var nsfw: Bool?
    public var waitTranscoding: Bool?
    public var state: VideoStateConstant?
    public var scheduledUpdate: VideoScheduledUpdate?
    public var blacklisted: Bool?
    public var blacklistedReason: String?
    public var account: Account?
    public var channel: VideoChannel?
    public var userHistory: VideoUserHistory?
    /** If the video is a live, you have the amount of current viewers */
    public var viewers: Int?
    /** path at which to get the full description of maximum `10000` characters */
    public var descriptionPath: String?
    /** A text tell the audience how to support the video creator */
    public var support: String?
    public var tags: [String]?
    public var commentsEnabled: Bool?
    public var downloadEnabled: Bool?
    /** Latest input file update. Null if the file has never been replaced since the original upload */
    public var inputFileUpdatedAt: Date?
    public var trackerUrls: [String]?
    /** Web compatible video files. If Web Video is disabled on the server:  - field will be empty - video files will be found in `streamingPlaylists[].files` field  */
    public var files: [VideoFile]?
    /** HLS playlists/manifest files. If HLS is disabled on the server:  - field will be empty - video files will be found in `files` field  */
    public var streamingPlaylists: [VideoStreamingPlaylists]?

    public init(id: Int? = nil, uuid: UUID? = nil, shortUUID: String? = nil, isLive: Bool? = nil, createdAt: Date? = nil, publishedAt: Date? = nil, updatedAt: Date? = nil, originallyPublishedAt: Date? = nil, category: VideoConstantNumberCategory? = nil, licence: VideoConstantNumberLicence? = nil, language: VideoConstantStringLanguage? = nil, privacy: VideoPrivacyConstant? = nil, description: String? = nil, duration: Int? = nil, isLocal: Bool? = nil, name: String? = nil, thumbnailPath: String? = nil, previewPath: String? = nil, embedPath: String? = nil, views: Int? = nil, likes: Int? = nil, dislikes: Int? = nil, nsfw: Bool? = nil, waitTranscoding: Bool? = nil, state: VideoStateConstant? = nil, scheduledUpdate: VideoScheduledUpdate? = nil, blacklisted: Bool? = nil, blacklistedReason: String? = nil, account: Account? = nil, channel: VideoChannel? = nil, userHistory: VideoUserHistory? = nil, viewers: Int? = nil, descriptionPath: String? = nil, support: String? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, downloadEnabled: Bool? = nil, inputFileUpdatedAt: Date? = nil, trackerUrls: [String]? = nil, files: [VideoFile]? = nil, streamingPlaylists: [VideoStreamingPlaylists]? = nil) {
        self.id = id
        self.uuid = uuid
        self.shortUUID = shortUUID
        self.isLive = isLive
        self.createdAt = createdAt
        self.publishedAt = publishedAt
        self.updatedAt = updatedAt
        self.originallyPublishedAt = originallyPublishedAt
        self.category = category
        self.licence = licence
        self.language = language
        self.privacy = privacy
        self.description = description
        self.duration = duration
        self.isLocal = isLocal
        self.name = name
        self.thumbnailPath = thumbnailPath
        self.previewPath = previewPath
        self.embedPath = embedPath
        self.views = views
        self.likes = likes
        self.dislikes = dislikes
        self.nsfw = nsfw
        self.waitTranscoding = waitTranscoding
        self.state = state
        self.scheduledUpdate = scheduledUpdate
        self.blacklisted = blacklisted
        self.blacklistedReason = blacklistedReason
        self.account = account
        self.channel = channel
        self.userHistory = userHistory
        self.viewers = viewers
        self.descriptionPath = descriptionPath
        self.support = support
        self.tags = tags
        self.commentsEnabled = commentsEnabled
        self.downloadEnabled = downloadEnabled
        self.inputFileUpdatedAt = inputFileUpdatedAt
        self.trackerUrls = trackerUrls
        self.files = files
        self.streamingPlaylists = streamingPlaylists
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case id
        case uuid
        case shortUUID
        case isLive
        case createdAt
        case publishedAt
        case updatedAt
        case originallyPublishedAt
        case category
        case licence
        case language
        case privacy
        case description
        case duration
        case isLocal
        case name
        case thumbnailPath
        case previewPath
        case embedPath
        case views
        case likes
        case dislikes
        case nsfw
        case waitTranscoding
        case state
        case scheduledUpdate
        case blacklisted
        case blacklistedReason
        case account
        case channel
        case userHistory
        case viewers
        case descriptionPath
        case support
        case tags
        case commentsEnabled
        case downloadEnabled
        case inputFileUpdatedAt
        case trackerUrls
        case files
        case streamingPlaylists
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(id, forKey: .id)
        try container.encodeIfPresent(uuid, forKey: .uuid)
        try container.encodeIfPresent(shortUUID, forKey: .shortUUID)
        try container.encodeIfPresent(isLive, forKey: .isLive)
        try container.encodeIfPresent(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(publishedAt, forKey: .publishedAt)
        try container.encodeIfPresent(updatedAt, forKey: .updatedAt)
        try container.encodeIfPresent(originallyPublishedAt, forKey: .originallyPublishedAt)
        try container.encodeIfPresent(category, forKey: .category)
        try container.encodeIfPresent(licence, forKey: .licence)
        try container.encodeIfPresent(language, forKey: .language)
        try container.encodeIfPresent(privacy, forKey: .privacy)
        try container.encodeIfPresent(description, forKey: .description)
        try container.encodeIfPresent(duration, forKey: .duration)
        try container.encodeIfPresent(isLocal, forKey: .isLocal)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(thumbnailPath, forKey: .thumbnailPath)
        try container.encodeIfPresent(previewPath, forKey: .previewPath)
        try container.encodeIfPresent(embedPath, forKey: .embedPath)
        try container.encodeIfPresent(views, forKey: .views)
        try container.encodeIfPresent(likes, forKey: .likes)
        try container.encodeIfPresent(dislikes, forKey: .dislikes)
        try container.encodeIfPresent(nsfw, forKey: .nsfw)
        try container.encodeIfPresent(waitTranscoding, forKey: .waitTranscoding)
        try container.encodeIfPresent(state, forKey: .state)
        try container.encodeIfPresent(scheduledUpdate, forKey: .scheduledUpdate)
        try container.encodeIfPresent(blacklisted, forKey: .blacklisted)
        try container.encodeIfPresent(blacklistedReason, forKey: .blacklistedReason)
        try container.encodeIfPresent(account, forKey: .account)
        try container.encodeIfPresent(channel, forKey: .channel)
        try container.encodeIfPresent(userHistory, forKey: .userHistory)
        try container.encodeIfPresent(viewers, forKey: .viewers)
        try container.encodeIfPresent(descriptionPath, forKey: .descriptionPath)
        try container.encodeIfPresent(support, forKey: .support)
        try container.encodeIfPresent(tags, forKey: .tags)
        try container.encodeIfPresent(commentsEnabled, forKey: .commentsEnabled)
        try container.encodeIfPresent(downloadEnabled, forKey: .downloadEnabled)
        try container.encodeIfPresent(inputFileUpdatedAt, forKey: .inputFileUpdatedAt)
        try container.encodeIfPresent(trackerUrls, forKey: .trackerUrls)
        try container.encodeIfPresent(files, forKey: .files)
        try container.encodeIfPresent(streamingPlaylists, forKey: .streamingPlaylists)
    }
}

