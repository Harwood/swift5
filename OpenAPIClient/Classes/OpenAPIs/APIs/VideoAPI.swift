//
// VideoAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class VideoAPI {

    /**
     Create a live
     
     - parameter channelId: (form) Channel id that will contain this live video 
     - parameter name: (form) Live video/replay name 
     - parameter saveReplay: (form)  (optional)
     - parameter replaySettings: (form)  (optional)
     - parameter permanentLive: (form) User can stream multiple times in a permanent live (optional)
     - parameter latencyMode: (form)  (optional)
     - parameter thumbnailfile: (form) Live video/replay thumbnail file (optional)
     - parameter previewfile: (form) Live video/replay preview file (optional)
     - parameter privacy: (form)  (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter description: (form) Live video/replay description (optional)
     - parameter support: (form) A text tell the audience how to support the creator (optional)
     - parameter nsfw: (form) Whether or not this live video/replay contains sensitive content (optional)
     - parameter tags: (form) Live video/replay tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Enable or disable comments for this live video/replay (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for the replay of this live video (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func addLive(channelId: Int, name: String, saveReplay: Bool? = nil, replaySettings: LiveVideoReplaySettings? = nil, permanentLive: Bool? = nil, latencyMode: LiveVideoLatencyMode? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, support: String? = nil, nsfw: Bool? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, downloadEnabled: Bool? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoUploadResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return addLiveWithRequestBuilder(channelId: channelId, name: name, saveReplay: saveReplay, replaySettings: replaySettings, permanentLive: permanentLive, latencyMode: latencyMode, thumbnailfile: thumbnailfile, previewfile: previewfile, privacy: privacy, category: category, licence: licence, language: language, description: description, support: support, nsfw: nsfw, tags: tags, commentsEnabled: commentsEnabled, downloadEnabled: downloadEnabled).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a live
     - POST /api/v1/videos/live
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter channelId: (form) Channel id that will contain this live video 
     - parameter name: (form) Live video/replay name 
     - parameter saveReplay: (form)  (optional)
     - parameter replaySettings: (form)  (optional)
     - parameter permanentLive: (form) User can stream multiple times in a permanent live (optional)
     - parameter latencyMode: (form)  (optional)
     - parameter thumbnailfile: (form) Live video/replay thumbnail file (optional)
     - parameter previewfile: (form) Live video/replay preview file (optional)
     - parameter privacy: (form)  (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter description: (form) Live video/replay description (optional)
     - parameter support: (form) A text tell the audience how to support the creator (optional)
     - parameter nsfw: (form) Whether or not this live video/replay contains sensitive content (optional)
     - parameter tags: (form) Live video/replay tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Enable or disable comments for this live video/replay (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for the replay of this live video (optional)
     - returns: RequestBuilder<VideoUploadResponse> 
     */
    open class func addLiveWithRequestBuilder(channelId: Int, name: String, saveReplay: Bool? = nil, replaySettings: LiveVideoReplaySettings? = nil, permanentLive: Bool? = nil, latencyMode: LiveVideoLatencyMode? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, support: String? = nil, nsfw: Bool? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, downloadEnabled: Bool? = nil) -> RequestBuilder<VideoUploadResponse> {
        let localVariablePath = "/api/v1/videos/live"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "channelId": channelId.encodeToJSON(),
            "saveReplay": saveReplay?.encodeToJSON(),
            "replaySettings": replaySettings?.encodeToJSON(),
            "permanentLive": permanentLive?.encodeToJSON(),
            "latencyMode": latencyMode?.encodeToJSON(),
            "thumbnailfile": thumbnailfile?.encodeToJSON(),
            "previewfile": previewfile?.encodeToJSON(),
            "privacy": privacy?.encodeToJSON(),
            "category": category?.encodeToJSON(),
            "licence": licence?.encodeToJSON(),
            "language": language?.encodeToJSON(),
            "description": description?.encodeToJSON(),
            "support": support?.encodeToJSON(),
            "nsfw": nsfw?.encodeToJSON(),
            "name": name.encodeToJSON(),
            "tags": tags?.encodeToJSON(),
            "commentsEnabled": commentsEnabled?.encodeToJSON(),
            "downloadEnabled": downloadEnabled?.encodeToJSON(),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoUploadResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Notify user is watching a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter userViewingVideo: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func addView(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, userViewingVideo: UserViewingVideo, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return addViewWithRequestBuilder(id: id, userViewingVideo: userViewingVideo).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Notify user is watching a video
     - POST /api/v1/videos/{id}/views
     - Call this endpoint regularly (every 5-10 seconds for example) to notify the server the user is watching the video. After a while, PeerTube will increase video's viewers counter. If the user is authenticated, PeerTube will also store the current player time.
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter userViewingVideo: (body)  
     - returns: RequestBuilder<Void> 
     */
    open class func addViewWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, userViewingVideo: UserViewingVideo) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}/views"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: userViewingVideo)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     Create a studio task
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func apiV1VideosIdStudioEditPost(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return apiV1VideosIdStudioEditPostWithRequestBuilder(id: id).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Create a studio task
     - POST /api/v1/videos/{id}/studio/edit
     - Create a task to edit a video  (cut, add intro/outro etc)
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - returns: RequestBuilder<Void> 
     */
    open class func apiV1VideosIdStudioEditPostWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}/studio/edit"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/x-www-form-urlencoded",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Set watching progress of a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter userViewingVideo: (body)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    @discardableResult
    open class func apiV1VideosIdWatchingPut(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, userViewingVideo: UserViewingVideo, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return apiV1VideosIdWatchingPutWithRequestBuilder(id: id, userViewingVideo: userViewingVideo).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Set watching progress of a video
     - PUT /api/v1/videos/{id}/watching
     - This endpoint has been deprecated. Use `/videos/{id}/views` instead
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter userViewingVideo: (body)  
     - returns: RequestBuilder<Void> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func apiV1VideosIdWatchingPutWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, userViewingVideo: UserViewingVideo) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}/watching"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: userViewingVideo)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Delete a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func delVideo(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return delVideoWithRequestBuilder(id: id).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Delete a video
     - DELETE /api/v1/videos/{id}
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - returns: RequestBuilder<Void> 
     */
    open class func delVideoWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_getAccountVideos: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_getAccountVideos: Int, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_getAccountVideos: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAccountVideos: String, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case trending = "-trending"
        case hot = "-hot"
        case best = "-best"
    }

    /**
     List videos of an account
     
     - parameter name: (path) The username or handle of the account 
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote videos (optional)
     - parameter include: (query) **PeerTube &gt;&#x3D; 4.0** Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getAccountVideos(name: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, nsfw: Nsfw_getAccountVideos? = nil, isLocal: Bool? = nil, include: Include_getAccountVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getAccountVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getAccountVideos? = nil, excludeAlreadyWatched: Bool? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoListResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getAccountVideosWithRequestBuilder(name: name, categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, nsfw: nsfw, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List videos of an account
     - GET /api/v1/accounts/{name}/videos
     - parameter name: (path) The username or handle of the account 
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote videos (optional)
     - parameter include: (query) **PeerTube &gt;&#x3D; 4.0** Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func getAccountVideosWithRequestBuilder(name: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, nsfw: Nsfw_getAccountVideos? = nil, isLocal: Bool? = nil, include: Include_getAccountVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getAccountVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getAccountVideos? = nil, excludeAlreadyWatched: Bool? = nil) -> RequestBuilder<VideoListResponse> {
        var localVariablePath = "/api/v1/accounts/{name}/videos"
        let namePreEscape = "\(APIHelper.mapValueToPathItem(name))"
        let namePostEscape = namePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{name}", with: namePostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(), isExplode: false),
            "isLive": (wrappedValue: isLive?.encodeToJSON(), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(), isExplode: false),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(), isExplode: false),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(), isExplode: false),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(), isExplode: false),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     List available video categories
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getCategories(apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: [String]?, _ error: Error?) -> Void)) -> RequestTask {
        return getCategoriesWithRequestBuilder().execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List available video categories
     - GET /api/v1/videos/categories
     - returns: RequestBuilder<[String]> 
     */
    open class func getCategoriesWithRequestBuilder() -> RequestBuilder<[String]> {
        let localVariablePath = "/api/v1/videos/categories"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     List available video languages
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getLanguages(apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: [String]?, _ error: Error?) -> Void)) -> RequestTask {
        return getLanguagesWithRequestBuilder().execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List available video languages
     - GET /api/v1/videos/languages
     - returns: RequestBuilder<[String]> 
     */
    open class func getLanguagesWithRequestBuilder() -> RequestBuilder<[String]> {
        let localVariablePath = "/api/v1/videos/languages"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     List available video licences
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getLicences(apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: [String]?, _ error: Error?) -> Void)) -> RequestTask {
        return getLicencesWithRequestBuilder().execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List available video licences
     - GET /api/v1/videos/licences
     - returns: RequestBuilder<[String]> 
     */
    open class func getLicencesWithRequestBuilder() -> RequestBuilder<[String]> {
        let localVariablePath = "/api/v1/videos/licences"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     Get information about a live
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getLiveId(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: LiveVideoResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getLiveIdWithRequestBuilder(id: id).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get information about a live
     - GET /api/v1/videos/live/{id}
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - returns: RequestBuilder<LiveVideoResponse> 
     */
    open class func getLiveIdWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter) -> RequestBuilder<LiveVideoResponse> {
        var localVariablePath = "/api/v1/videos/live/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<LiveVideoResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getVideo(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoDetails?, _ error: Error?) -> Void)) -> RequestTask {
        return getVideoWithRequestBuilder(id: id, xPeertubeVideoPassword: xPeertubeVideoPassword).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get a video
     - GET /api/v1/videos/{id}
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - returns: RequestBuilder<VideoDetails> 
     */
    open class func getVideoWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil) -> RequestBuilder<VideoDetails> {
        var localVariablePath = "/api/v1/videos/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "x-peertube-video-password": xPeertubeVideoPassword?.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoDetails>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_getVideoChannelVideos: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_getVideoChannelVideos: Int, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_getVideoChannelVideos: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getVideoChannelVideos: String, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case trending = "-trending"
        case hot = "-hot"
        case best = "-best"
    }

    /**
     List videos of a video channel
     
     - parameter channelHandle: (path) The video channel handle 
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote videos (optional)
     - parameter include: (query) **PeerTube &gt;&#x3D; 4.0** Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getVideoChannelVideos(channelHandle: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, nsfw: Nsfw_getVideoChannelVideos? = nil, isLocal: Bool? = nil, include: Include_getVideoChannelVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getVideoChannelVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getVideoChannelVideos? = nil, excludeAlreadyWatched: Bool? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoListResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getVideoChannelVideosWithRequestBuilder(channelHandle: channelHandle, categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, nsfw: nsfw, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List videos of a video channel
     - GET /api/v1/video-channels/{channelHandle}/videos
     - parameter channelHandle: (path) The video channel handle 
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote videos (optional)
     - parameter include: (query) **PeerTube &gt;&#x3D; 4.0** Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func getVideoChannelVideosWithRequestBuilder(channelHandle: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, nsfw: Nsfw_getVideoChannelVideos? = nil, isLocal: Bool? = nil, include: Include_getVideoChannelVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getVideoChannelVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getVideoChannelVideos? = nil, excludeAlreadyWatched: Bool? = nil) -> RequestBuilder<VideoListResponse> {
        var localVariablePath = "/api/v1/video-channels/{channelHandle}/videos"
        let channelHandlePreEscape = "\(APIHelper.mapValueToPathItem(channelHandle))"
        let channelHandlePostEscape = channelHandlePreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{channelHandle}", with: channelHandlePostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(), isExplode: false),
            "isLive": (wrappedValue: isLive?.encodeToJSON(), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(), isExplode: false),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(), isExplode: false),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(), isExplode: false),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(), isExplode: false),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     Get complete video description
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getVideoDesc(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: String?, _ error: Error?) -> Void)) -> RequestTask {
        return getVideoDescWithRequestBuilder(id: id, xPeertubeVideoPassword: xPeertubeVideoPassword).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get complete video description
     - GET /api/v1/videos/{id}/description
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - returns: RequestBuilder<String> 
     */
    open class func getVideoDescWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil) -> RequestBuilder<String> {
        var localVariablePath = "/api/v1/videos/{id}/description"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "x-peertube-video-password": xPeertubeVideoPassword?.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<String>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     List available video privacy policies
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getVideoPrivacyPolicies(apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: [String]?, _ error: Error?) -> Void)) -> RequestTask {
        return getVideoPrivacyPoliciesWithRequestBuilder().execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List available video privacy policies
     - GET /api/v1/videos/privacies
     - returns: RequestBuilder<[String]> 
     */
    open class func getVideoPrivacyPoliciesWithRequestBuilder() -> RequestBuilder<[String]> {
        let localVariablePath = "/api/v1/videos/privacies"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[String]>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     Get video source file metadata
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getVideoSource(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoSource?, _ error: Error?) -> Void)) -> RequestTask {
        return getVideoSourceWithRequestBuilder(id: id).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get video source file metadata
     - GET /api/v1/videos/{id}/source
     - parameter id: (path) The object id, uuid or short uuid 
     - returns: RequestBuilder<VideoSource> 
     */
    open class func getVideoSourceWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter) -> RequestBuilder<VideoSource> {
        var localVariablePath = "/api/v1/videos/{id}/source"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoSource>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_getVideos: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_getVideos: Int, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_getVideos: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getVideos: String, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case trending = "-trending"
        case hot = "-hot"
        case best = "-best"
    }

    /**
     List videos
     
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote videos (optional)
     - parameter include: (query) **PeerTube &gt;&#x3D; 4.0** Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func getVideos(categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, nsfw: Nsfw_getVideos? = nil, isLocal: Bool? = nil, include: Include_getVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getVideos? = nil, excludeAlreadyWatched: Bool? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoListResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return getVideosWithRequestBuilder(categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, nsfw: nsfw, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List videos
     - GET /api/v1/videos
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote videos (optional)
     - parameter include: (query) **PeerTube &gt;&#x3D; 4.0** Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter sort: (query)  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func getVideosWithRequestBuilder(categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, nsfw: Nsfw_getVideos? = nil, isLocal: Bool? = nil, include: Include_getVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_getVideos? = nil, start: Int? = nil, count: Int? = nil, sort: Sort_getVideos? = nil, excludeAlreadyWatched: Bool? = nil) -> RequestBuilder<VideoListResponse> {
        let localVariablePath = "/api/v1/videos"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(), isExplode: false),
            "isLive": (wrappedValue: isLive?.encodeToJSON(), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(), isExplode: false),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(), isExplode: false),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(), isExplode: false),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(), isExplode: false),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     List storyboards of a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func listVideoStoryboards(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: ListVideoStoryboards200Response?, _ error: Error?) -> Void)) -> RequestTask {
        return listVideoStoryboardsWithRequestBuilder(id: id).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     List storyboards of a video
     - GET /api/v1/videos/{id}/storyboards
     - **PeerTube** >= 6.0
     - parameter id: (path) The object id, uuid or short uuid 
     - returns: RequestBuilder<ListVideoStoryboards200Response> 
     */
    open class func listVideoStoryboardsWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter) -> RequestBuilder<ListVideoStoryboards200Response> {
        var localVariablePath = "/api/v1/videos/{id}/storyboards"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ListVideoStoryboards200Response>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     Update a video
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter thumbnailfile: (form) Video thumbnail file (optional)
     - parameter previewfile: (form) Video preview file (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter privacy: (form)  (optional)
     - parameter description: (form) Video description (optional)
     - parameter waitTranscoding: (form) Whether or not we wait transcoding before publish the video (optional)
     - parameter support: (form) A text tell the audience how to support the video creator (optional)
     - parameter nsfw: (form) Whether or not this video contains sensitive content (optional)
     - parameter name: (form) Video name (optional)
     - parameter tags: (form) Video tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Enable or disable comments for this video (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for this video (optional)
     - parameter originallyPublishedAt: (form) Date when the content was originally published (optional)
     - parameter scheduleUpdate: (form)  (optional)
     - parameter videoPasswords: (form)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func putVideo(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, thumbnailfile: URL? = nil, previewfile: URL? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, privacy: VideoPrivacySet? = nil, description: String? = nil, waitTranscoding: String? = nil, support: String? = nil, nsfw: Bool? = nil, name: String? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, videoPasswords: Set<String>? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return putVideoWithRequestBuilder(id: id, thumbnailfile: thumbnailfile, previewfile: previewfile, category: category, licence: licence, language: language, privacy: privacy, description: description, waitTranscoding: waitTranscoding, support: support, nsfw: nsfw, name: name, tags: tags, commentsEnabled: commentsEnabled, downloadEnabled: downloadEnabled, originallyPublishedAt: originallyPublishedAt, scheduleUpdate: scheduleUpdate, videoPasswords: videoPasswords).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Update a video
     - PUT /api/v1/videos/{id}
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter thumbnailfile: (form) Video thumbnail file (optional)
     - parameter previewfile: (form) Video preview file (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter privacy: (form)  (optional)
     - parameter description: (form) Video description (optional)
     - parameter waitTranscoding: (form) Whether or not we wait transcoding before publish the video (optional)
     - parameter support: (form) A text tell the audience how to support the video creator (optional)
     - parameter nsfw: (form) Whether or not this video contains sensitive content (optional)
     - parameter name: (form) Video name (optional)
     - parameter tags: (form) Video tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Enable or disable comments for this video (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for this video (optional)
     - parameter originallyPublishedAt: (form) Date when the content was originally published (optional)
     - parameter scheduleUpdate: (form)  (optional)
     - parameter videoPasswords: (form)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func putVideoWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, thumbnailfile: URL? = nil, previewfile: URL? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, privacy: VideoPrivacySet? = nil, description: String? = nil, waitTranscoding: String? = nil, support: String? = nil, nsfw: Bool? = nil, name: String? = nil, tags: [String]? = nil, commentsEnabled: Bool? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, videoPasswords: Set<String>? = nil) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "thumbnailfile": thumbnailfile?.encodeToJSON(),
            "previewfile": previewfile?.encodeToJSON(),
            "category": category?.encodeToJSON(),
            "licence": licence?.encodeToJSON(),
            "language": language?.encodeToJSON(),
            "privacy": privacy?.encodeToJSON(),
            "description": description?.encodeToJSON(),
            "waitTranscoding": waitTranscoding?.encodeToJSON(),
            "support": support?.encodeToJSON(),
            "nsfw": nsfw?.encodeToJSON(),
            "name": name?.encodeToJSON(),
            "tags": tags?.encodeToJSON(),
            "commentsEnabled": commentsEnabled?.encodeToJSON(),
            "downloadEnabled": downloadEnabled?.encodeToJSON(),
            "originallyPublishedAt": originallyPublishedAt?.encodeToJSON(),
            "scheduleUpdate": scheduleUpdate?.encodeToJSON(),
            "videoPasswords": videoPasswords?.encodeToJSON(),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Send chunk for the resumable replacement of a video
     
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentRange: (header) Specifies the bytes in the file that the request is uploading.  For example, a value of &#x60;bytes 0-262143/1000000&#x60; shows that the request is sending the first 262144 bytes (256 x 1024) in a 2,469,036 byte file.  
     - parameter contentLength: (header) Size of the chunk that the request is sending.  Remember that larger chunks are more efficient. PeerTube&#39;s web client uses chunks varying from 1048576 bytes (~1MB) and increases or reduces size depending on connection health.  
     - parameter body: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func replaceVideoSourceResumable(uploadId: String, contentRange: String, contentLength: Double, body: URL? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return replaceVideoSourceResumableWithRequestBuilder(uploadId: uploadId, contentRange: contentRange, contentLength: contentLength, body: body).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Send chunk for the resumable replacement of a video
     - PUT /api/v1/videos/{id}/source/replace-resumable
     - **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to continue, pause or resume the replacement of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentRange: (header) Specifies the bytes in the file that the request is uploading.  For example, a value of &#x60;bytes 0-262143/1000000&#x60; shows that the request is sending the first 262144 bytes (256 x 1024) in a 2,469,036 byte file.  
     - parameter contentLength: (header) Size of the chunk that the request is sending.  Remember that larger chunks are more efficient. PeerTube&#39;s web client uses chunks varying from 1048576 bytes (~1MB) and increases or reduces size depending on connection health.  
     - parameter body: (body)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func replaceVideoSourceResumableWithRequestBuilder(uploadId: String, contentRange: String, contentLength: Double, body: URL? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/{id}/source/replace-resumable"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters = ["body": body]

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "upload_id": (wrappedValue: uploadId.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/octet-stream",
            "Content-Range": contentRange.encodeToJSON(),
            "Content-Length": contentLength.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Cancel the resumable replacement of a video
     
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentLength: (header)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func replaceVideoSourceResumableCancel(uploadId: String, contentLength: Double, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return replaceVideoSourceResumableCancelWithRequestBuilder(uploadId: uploadId, contentLength: contentLength).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Cancel the resumable replacement of a video
     - DELETE /api/v1/videos/{id}/source/replace-resumable
     - **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to cancel the replacement of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - responseHeaders: [Content-Length(Double)]
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentLength: (header)  
     - returns: RequestBuilder<Void> 
     */
    open class func replaceVideoSourceResumableCancelWithRequestBuilder(uploadId: String, contentLength: Double) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/{id}/source/replace-resumable"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "upload_id": (wrappedValue: uploadId.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Length": contentLength.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Initialize the resumable replacement of a video
     
     - parameter xUploadContentLength: (header) Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. 
     - parameter xUploadContentType: (header) MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. 
     - parameter videoReplaceSourceRequestResumable: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func replaceVideoSourceResumableInit(xUploadContentLength: Double, xUploadContentType: String, videoReplaceSourceRequestResumable: VideoReplaceSourceRequestResumable? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return replaceVideoSourceResumableInitWithRequestBuilder(xUploadContentLength: xUploadContentLength, xUploadContentType: xUploadContentType, videoReplaceSourceRequestResumable: videoReplaceSourceRequestResumable).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Initialize the resumable replacement of a video
     - POST /api/v1/videos/{id}/source/replace-resumable
     - **PeerTube >= 6.0** Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to initialize the replacement of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter xUploadContentLength: (header) Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. 
     - parameter xUploadContentType: (header) MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. 
     - parameter videoReplaceSourceRequestResumable: (body)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func replaceVideoSourceResumableInitWithRequestBuilder(xUploadContentLength: Double, xUploadContentType: String, videoReplaceSourceRequestResumable: VideoReplaceSourceRequestResumable? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/{id}/source/replace-resumable"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: videoReplaceSourceRequestResumable)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
            "X-Upload-Content-Length": xUploadContentLength.encodeToJSON(),
            "X-Upload-Content-Type": xUploadContentType.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Request video token
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func requestVideoToken(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoTokenResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return requestVideoTokenWithRequestBuilder(id: id, xPeertubeVideoPassword: xPeertubeVideoPassword).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Request video token
     - POST /api/v1/videos/{id}/token
     - Request special tokens that expire quickly to use them in some context (like accessing private static files)
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter xPeertubeVideoPassword: (header) Required on password protected video (optional)
     - returns: RequestBuilder<VideoTokenResponse> 
     */
    open class func requestVideoTokenWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, xPeertubeVideoPassword: String? = nil) -> RequestBuilder<VideoTokenResponse> {
        var localVariablePath = "/api/v1/videos/{id}/token"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "x-peertube-video-password": xPeertubeVideoPassword?.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoTokenResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Update information about a live
     
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter liveVideoUpdate: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func updateLiveId(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, liveVideoUpdate: LiveVideoUpdate? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return updateLiveIdWithRequestBuilder(id: id, liveVideoUpdate: liveVideoUpdate).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Update information about a live
     - PUT /api/v1/videos/live/{id}
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter id: (path) The object id, uuid or short uuid 
     - parameter liveVideoUpdate: (body)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func updateLiveIdWithRequestBuilder(id: ApiV1VideosOwnershipIdAcceptPostIdParameter, liveVideoUpdate: LiveVideoUpdate? = nil) -> RequestBuilder<Void> {
        var localVariablePath = "/api/v1/videos/live/{id}"
        let idPreEscape = "\(APIHelper.mapValueToPathItem(id))"
        let idPostEscape = idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: idPostEscape, options: .literal, range: nil)
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: liveVideoUpdate)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Upload a video
     
     - parameter name: (form) Video name 
     - parameter channelId: (form) Channel id that will contain this video 
     - parameter videofile: (form) Video file 
     - parameter privacy: (form)  (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter description: (form) Video description (optional)
     - parameter waitTranscoding: (form) Whether or not we wait transcoding before publish the video (optional)
     - parameter support: (form) A text tell the audience how to support the video creator (optional)
     - parameter nsfw: (form) Whether or not this video contains sensitive content (optional)
     - parameter tags: (form) Video tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Enable or disable comments for this video (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for this video (optional)
     - parameter originallyPublishedAt: (form) Date when the content was originally published (optional)
     - parameter scheduleUpdate: (form)  (optional)
     - parameter thumbnailfile: (form) Video thumbnail file (optional)
     - parameter previewfile: (form) Video preview file (optional)
     - parameter videoPasswords: (form)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadLegacy(name: String, channelId: Int, videofile: URL, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, waitTranscoding: Bool? = nil, support: String? = nil, nsfw: Bool? = nil, tags: Set<String>? = nil, commentsEnabled: Bool? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, videoPasswords: Set<String>? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoUploadResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadLegacyWithRequestBuilder(name: name, channelId: channelId, videofile: videofile, privacy: privacy, category: category, licence: licence, language: language, description: description, waitTranscoding: waitTranscoding, support: support, nsfw: nsfw, tags: tags, commentsEnabled: commentsEnabled, downloadEnabled: downloadEnabled, originallyPublishedAt: originallyPublishedAt, scheduleUpdate: scheduleUpdate, thumbnailfile: thumbnailfile, previewfile: previewfile, videoPasswords: videoPasswords).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Upload a video
     - POST /api/v1/videos/upload
     - Uses a single request to upload a video.
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter name: (form) Video name 
     - parameter channelId: (form) Channel id that will contain this video 
     - parameter videofile: (form) Video file 
     - parameter privacy: (form)  (optional)
     - parameter category: (form) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter licence: (form) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter language: (form) language id of the video (see [/videos/languages](#operation/getLanguages)) (optional)
     - parameter description: (form) Video description (optional)
     - parameter waitTranscoding: (form) Whether or not we wait transcoding before publish the video (optional)
     - parameter support: (form) A text tell the audience how to support the video creator (optional)
     - parameter nsfw: (form) Whether or not this video contains sensitive content (optional)
     - parameter tags: (form) Video tags (maximum 5 tags each between 2 and 30 characters) (optional)
     - parameter commentsEnabled: (form) Enable or disable comments for this video (optional)
     - parameter downloadEnabled: (form) Enable or disable downloading for this video (optional)
     - parameter originallyPublishedAt: (form) Date when the content was originally published (optional)
     - parameter scheduleUpdate: (form)  (optional)
     - parameter thumbnailfile: (form) Video thumbnail file (optional)
     - parameter previewfile: (form) Video preview file (optional)
     - parameter videoPasswords: (form)  (optional)
     - returns: RequestBuilder<VideoUploadResponse> 
     */
    open class func uploadLegacyWithRequestBuilder(name: String, channelId: Int, videofile: URL, privacy: VideoPrivacySet? = nil, category: Int? = nil, licence: Int? = nil, language: String? = nil, description: String? = nil, waitTranscoding: Bool? = nil, support: String? = nil, nsfw: Bool? = nil, tags: Set<String>? = nil, commentsEnabled: Bool? = nil, downloadEnabled: Bool? = nil, originallyPublishedAt: Date? = nil, scheduleUpdate: VideoScheduledUpdate? = nil, thumbnailfile: URL? = nil, previewfile: URL? = nil, videoPasswords: Set<String>? = nil) -> RequestBuilder<VideoUploadResponse> {
        let localVariablePath = "/api/v1/videos/upload"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableFormParams: [String: Any?] = [
            "name": name.encodeToJSON(),
            "channelId": channelId.encodeToJSON(),
            "privacy": privacy?.encodeToJSON(),
            "category": category?.encodeToJSON(),
            "licence": licence?.encodeToJSON(),
            "language": language?.encodeToJSON(),
            "description": description?.encodeToJSON(),
            "waitTranscoding": waitTranscoding?.encodeToJSON(),
            "support": support?.encodeToJSON(),
            "nsfw": nsfw?.encodeToJSON(),
            "tags": tags?.encodeToJSON(),
            "commentsEnabled": commentsEnabled?.encodeToJSON(),
            "downloadEnabled": downloadEnabled?.encodeToJSON(),
            "originallyPublishedAt": originallyPublishedAt?.encodeToJSON(),
            "scheduleUpdate": scheduleUpdate?.encodeToJSON(),
            "thumbnailfile": thumbnailfile?.encodeToJSON(),
            "previewfile": previewfile?.encodeToJSON(),
            "videoPasswords": videoPasswords?.encodeToJSON(),
            "videofile": videofile.encodeToJSON(),
        ]

        let localVariableNonNullParameters = APIHelper.rejectNil(localVariableFormParams)
        let localVariableParameters = APIHelper.convertBoolToString(localVariableNonNullParameters)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "multipart/form-data",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoUploadResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Send chunk for the resumable upload of a video
     
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentRange: (header) Specifies the bytes in the file that the request is uploading.  For example, a value of &#x60;bytes 0-262143/1000000&#x60; shows that the request is sending the first 262144 bytes (256 x 1024) in a 2,469,036 byte file.  
     - parameter contentLength: (header) Size of the chunk that the request is sending.  Remember that larger chunks are more efficient. PeerTube&#39;s web client uses chunks varying from 1048576 bytes (~1MB) and increases or reduces size depending on connection health.  
     - parameter body: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadResumable(uploadId: String, contentRange: String, contentLength: Double, body: URL? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoUploadResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadResumableWithRequestBuilder(uploadId: uploadId, contentRange: contentRange, contentLength: contentLength, body: body).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Send chunk for the resumable upload of a video
     - PUT /api/v1/videos/upload-resumable
     - Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to continue, pause or resume the upload of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - responseHeaders: [Content-Length(Double)]
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentRange: (header) Specifies the bytes in the file that the request is uploading.  For example, a value of &#x60;bytes 0-262143/1000000&#x60; shows that the request is sending the first 262144 bytes (256 x 1024) in a 2,469,036 byte file.  
     - parameter contentLength: (header) Size of the chunk that the request is sending.  Remember that larger chunks are more efficient. PeerTube&#39;s web client uses chunks varying from 1048576 bytes (~1MB) and increases or reduces size depending on connection health.  
     - parameter body: (body)  (optional)
     - returns: RequestBuilder<VideoUploadResponse> 
     */
    open class func uploadResumableWithRequestBuilder(uploadId: String, contentRange: String, contentLength: Double, body: URL? = nil) -> RequestBuilder<VideoUploadResponse> {
        let localVariablePath = "/api/v1/videos/upload-resumable"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters = ["body": body]

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "upload_id": (wrappedValue: uploadId.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/octet-stream",
            "Content-Range": contentRange.encodeToJSON(),
            "Content-Length": contentLength.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoUploadResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Cancel the resumable upload of a video, deleting any data uploaded so far
     
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentLength: (header)  
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadResumableCancel(uploadId: String, contentLength: Double, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadResumableCancelWithRequestBuilder(uploadId: uploadId, contentLength: contentLength).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Cancel the resumable upload of a video, deleting any data uploaded so far
     - DELETE /api/v1/videos/upload-resumable
     - Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to cancel the upload of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - responseHeaders: [Content-Length(Double)]
     - parameter uploadId: (query) Created session id to proceed with. If you didn&#39;t send chunks in the last hour, it is not valid anymore and you need to initialize a new upload.  
     - parameter contentLength: (header)  
     - returns: RequestBuilder<Void> 
     */
    open class func uploadResumableCancelWithRequestBuilder(uploadId: String, contentLength: Double) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/upload-resumable"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "upload_id": (wrappedValue: uploadId.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Length": contentLength.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Initialize the resumable upload of a video
     
     - parameter xUploadContentLength: (header) Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. 
     - parameter xUploadContentType: (header) MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. 
     - parameter videoUploadRequestResumable: (body)  (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func uploadResumableInit(xUploadContentLength: Double, xUploadContentType: String, videoUploadRequestResumable: VideoUploadRequestResumable? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: Void?, _ error: Error?) -> Void)) -> RequestTask {
        return uploadResumableInitWithRequestBuilder(xUploadContentLength: xUploadContentLength, xUploadContentType: xUploadContentType, videoUploadRequestResumable: videoUploadRequestResumable).execute(apiResponseQueue) { result in
            switch result {
            case .success:
                completion((), nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Initialize the resumable upload of a video
     - POST /api/v1/videos/upload-resumable
     - Uses [a resumable protocol](https://github.com/kukhariev/node-uploadx/blob/master/proto.md) to initialize the upload of a video
     - OAuth:
       - type: oauth2
       - name: OAuth2
     - parameter xUploadContentLength: (header) Number of bytes that will be uploaded in subsequent requests. Set this value to the size of the file you are uploading. 
     - parameter xUploadContentType: (header) MIME type of the file that you are uploading. Depending on your instance settings, acceptable values might vary. 
     - parameter videoUploadRequestResumable: (body)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func uploadResumableInitWithRequestBuilder(xUploadContentLength: Double, xUploadContentType: String, videoUploadRequestResumable: VideoUploadRequestResumable? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/api/v1/videos/upload-resumable"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: videoUploadRequestResumable)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
            "X-Upload-Content-Length": xUploadContentLength.encodeToJSON(),
            "X-Upload-Content-Type": xUploadContentType.encodeToJSON(),
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = OpenAPIClientAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }
}
