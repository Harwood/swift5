//
// SearchAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
#if canImport(AnyCodable)
import AnyCodable
#endif

open class SearchAPI {

    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchChannels: String, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     Search channels
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete channel information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func searchChannels(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchChannels? = nil, sort: String? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoChannelList?, _ error: Error?) -> Void)) -> RequestTask {
        return searchChannelsWithRequestBuilder(search: search, start: start, count: count, searchTarget: searchTarget, sort: sort).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Search channels
     - GET /api/v1/search/video-channels
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete channel information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - returns: RequestBuilder<VideoChannelList> 
     */
    open class func searchChannelsWithRequestBuilder(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchChannels? = nil, sort: String? = nil) -> RequestBuilder<VideoChannelList> {
        let localVariablePath = "/api/v1/search/video-channels"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": (wrappedValue: search.encodeToJSON(), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(), isExplode: true),
            "searchTarget": (wrappedValue: searchTarget?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoChannelList>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchPlaylists: String, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     Search playlists
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete playlist information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func searchPlaylists(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchPlaylists? = nil, sort: String? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response?, _ error: Error?) -> Void)) -> RequestTask {
        return searchPlaylistsWithRequestBuilder(search: search, start: start, count: count, searchTarget: searchTarget, sort: sort).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Search playlists
     - GET /api/v1/search/video-playlists
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete playlist information and interact with it.  
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort column (optional)
     - returns: RequestBuilder<ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response> 
     */
    open class func searchPlaylistsWithRequestBuilder(search: String, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchPlaylists? = nil, sort: String? = nil) -> RequestBuilder<ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response> {
        let localVariablePath = "/api/v1/search/video-playlists"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": (wrappedValue: search.encodeToJSON(), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(), isExplode: true),
            "searchTarget": (wrappedValue: searchTarget?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ApiV1VideoChannelsChannelHandleVideoPlaylistsGet200Response>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }

    /**
     * enum for parameter nsfw
     */
    public enum Nsfw_searchVideos: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter include
     */
    public enum Include_searchVideos: Int, CaseIterable {
        case _0 = 0
        case _1 = 1
        case _2 = 2
        case _4 = 4
        case _8 = 8
    }

    /**
     * enum for parameter skipCount
     */
    public enum SkipCount_searchVideos: String, CaseIterable {
        case _true = "true"
        case _false = "false"
    }

    /**
     * enum for parameter searchTarget
     */
    public enum SearchTarget_searchVideos: String, CaseIterable {
        case local = "local"
        case searchIndex = "search-index"
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_searchVideos: String, CaseIterable {
        case name = "name"
        case duration = "-duration"
        case createdat = "-createdAt"
        case publishedat = "-publishedAt"
        case views = "-views"
        case likes = "-likes"
        case match = "-match"
    }

    /**
     Search videos
     
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.  
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote videos (optional)
     - parameter include: (query) **PeerTube &gt;&#x3D; 4.0** Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter uuids: (query) Find videos with specific UUIDs (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort videos by criteria (prefixing with &#x60;-&#x60; means &#x60;DESC&#x60; order):  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter startDate: (query) Get videos that are published after this date (optional)
     - parameter endDate: (query) Get videos that are published before this date (optional)
     - parameter originallyPublishedStartDate: (query) Get videos that are originally published after this date (optional)
     - parameter originallyPublishedEndDate: (query) Get videos that are originally published before this date (optional)
     - parameter durationMin: (query) Get videos that have this minimum duration (optional)
     - parameter durationMax: (query) Get videos that have this maximum duration (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    @discardableResult
    open class func searchVideos(search: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, nsfw: Nsfw_searchVideos? = nil, isLocal: Bool? = nil, include: Include_searchVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, uuids: [String]? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_searchVideos? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideos? = nil, sort: Sort_searchVideos? = nil, excludeAlreadyWatched: Bool? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil, apiResponseQueue: DispatchQueue = OpenAPIClientAPI.apiResponseQueue, completion: @escaping ((_ data: VideoListResponse?, _ error: Error?) -> Void)) -> RequestTask {
        return searchVideosWithRequestBuilder(search: search, categoryOneOf: categoryOneOf, isLive: isLive, tagsOneOf: tagsOneOf, tagsAllOf: tagsAllOf, licenceOneOf: licenceOneOf, languageOneOf: languageOneOf, nsfw: nsfw, isLocal: isLocal, include: include, privacyOneOf: privacyOneOf, uuids: uuids, hasHLSFiles: hasHLSFiles, hasWebVideoFiles: hasWebVideoFiles, skipCount: skipCount, start: start, count: count, searchTarget: searchTarget, sort: sort, excludeAlreadyWatched: excludeAlreadyWatched, startDate: startDate, endDate: endDate, originallyPublishedStartDate: originallyPublishedStartDate, originallyPublishedEndDate: originallyPublishedEndDate, durationMin: durationMin, durationMax: durationMax).execute(apiResponseQueue) { result in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Search videos
     - GET /api/v1/search/videos
     - parameter search: (query) String to search. If the user can make a remote URI search, and the string is an URI then the PeerTube instance will fetch the remote object and add it to its database. Then, you can use the REST API to fetch the complete video information and interact with it.  
     - parameter categoryOneOf: (query) category id of the video (see [/videos/categories](#operation/getCategories)) (optional)
     - parameter isLive: (query) whether or not the video is a live (optional)
     - parameter tagsOneOf: (query) tag(s) of the video (optional)
     - parameter tagsAllOf: (query) tag(s) of the video, where all should be present in the video (optional)
     - parameter licenceOneOf: (query) licence id of the video (see [/videos/licences](#operation/getLicences)) (optional)
     - parameter languageOneOf: (query) language id of the video (see [/videos/languages](#operation/getLanguages)). Use &#x60;_unknown&#x60; to filter on videos that don&#39;t have a video language (optional)
     - parameter nsfw: (query) whether to include nsfw videos, if any (optional)
     - parameter isLocal: (query) **PeerTube &gt;&#x3D; 4.0** Display only local or remote videos (optional)
     - parameter include: (query) **PeerTube &gt;&#x3D; 4.0** Include additional videos in results (can be combined using bitwise or operator) - &#x60;0&#x60; NONE - &#x60;1&#x60; NOT_PUBLISHED_STATE - &#x60;2&#x60; BLACKLISTED - &#x60;4&#x60; BLOCKED_OWNER - &#x60;8&#x60; FILES  (optional)
     - parameter privacyOneOf: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos in this specific privacy/privacies (optional)
     - parameter uuids: (query) Find videos with specific UUIDs (optional)
     - parameter hasHLSFiles: (query) **PeerTube &gt;&#x3D; 4.0** Display only videos that have HLS files (optional)
     - parameter hasWebVideoFiles: (query) **PeerTube &gt;&#x3D; 6.0** Display only videos that have Web Video files (optional)
     - parameter skipCount: (query) if you don&#39;t need the &#x60;total&#x60; in the response (optional, default to ._false)
     - parameter start: (query) Offset used to paginate results (optional)
     - parameter count: (query) Number of items to return (optional, default to 15)
     - parameter searchTarget: (query) If the administrator enabled search index support, you can override the default search target.  **Warning**: If you choose to make an index search, PeerTube will get results from a third party service. It means the instance may not yet know the objects you fetched. If you want to load video/channel information:   * If the current user has the ability to make a remote URI search (this information is available in the config endpoint),   then reuse the search API to make a search using the object URI so PeerTube instance fetches the remote object and fill its database.   After that, you can use the classic REST API endpoints to fetch the complete object or interact with it   * If the current user doesn&#39;t have the ability to make a remote URI search, then redirect the user on the origin instance or fetch   the data from the origin instance API  (optional)
     - parameter sort: (query) Sort videos by criteria (prefixing with &#x60;-&#x60; means &#x60;DESC&#x60; order):  (optional)
     - parameter excludeAlreadyWatched: (query) Whether or not to exclude videos that are in the user&#39;s video history (optional)
     - parameter startDate: (query) Get videos that are published after this date (optional)
     - parameter endDate: (query) Get videos that are published before this date (optional)
     - parameter originallyPublishedStartDate: (query) Get videos that are originally published after this date (optional)
     - parameter originallyPublishedEndDate: (query) Get videos that are originally published before this date (optional)
     - parameter durationMin: (query) Get videos that have this minimum duration (optional)
     - parameter durationMax: (query) Get videos that have this maximum duration (optional)
     - returns: RequestBuilder<VideoListResponse> 
     */
    open class func searchVideosWithRequestBuilder(search: String, categoryOneOf: GetAccountVideosCategoryOneOfParameter? = nil, isLive: Bool? = nil, tagsOneOf: GetAccountVideosTagsOneOfParameter? = nil, tagsAllOf: GetAccountVideosTagsAllOfParameter? = nil, licenceOneOf: GetAccountVideosLicenceOneOfParameter? = nil, languageOneOf: GetAccountVideosLanguageOneOfParameter? = nil, nsfw: Nsfw_searchVideos? = nil, isLocal: Bool? = nil, include: Include_searchVideos? = nil, privacyOneOf: VideoPrivacySet? = nil, uuids: [String]? = nil, hasHLSFiles: Bool? = nil, hasWebVideoFiles: Bool? = nil, skipCount: SkipCount_searchVideos? = nil, start: Int? = nil, count: Int? = nil, searchTarget: SearchTarget_searchVideos? = nil, sort: Sort_searchVideos? = nil, excludeAlreadyWatched: Bool? = nil, startDate: Date? = nil, endDate: Date? = nil, originallyPublishedStartDate: Date? = nil, originallyPublishedEndDate: Date? = nil, durationMin: Int? = nil, durationMax: Int? = nil) -> RequestBuilder<VideoListResponse> {
        let localVariablePath = "/api/v1/search/videos"
        let localVariableURLString = OpenAPIClientAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "search": (wrappedValue: search.encodeToJSON(), isExplode: true),
            "categoryOneOf": (wrappedValue: categoryOneOf?.encodeToJSON(), isExplode: false),
            "isLive": (wrappedValue: isLive?.encodeToJSON(), isExplode: true),
            "tagsOneOf": (wrappedValue: tagsOneOf?.encodeToJSON(), isExplode: false),
            "tagsAllOf": (wrappedValue: tagsAllOf?.encodeToJSON(), isExplode: false),
            "licenceOneOf": (wrappedValue: licenceOneOf?.encodeToJSON(), isExplode: false),
            "languageOneOf": (wrappedValue: languageOneOf?.encodeToJSON(), isExplode: false),
            "nsfw": (wrappedValue: nsfw?.encodeToJSON(), isExplode: true),
            "isLocal": (wrappedValue: isLocal?.encodeToJSON(), isExplode: true),
            "include": (wrappedValue: include?.encodeToJSON(), isExplode: true),
            "privacyOneOf": (wrappedValue: privacyOneOf?.encodeToJSON(), isExplode: true),
            "uuids": (wrappedValue: uuids?.encodeToJSON(), isExplode: true),
            "hasHLSFiles": (wrappedValue: hasHLSFiles?.encodeToJSON(), isExplode: true),
            "hasWebVideoFiles": (wrappedValue: hasWebVideoFiles?.encodeToJSON(), isExplode: true),
            "skipCount": (wrappedValue: skipCount?.encodeToJSON(), isExplode: true),
            "start": (wrappedValue: start?.encodeToJSON(), isExplode: true),
            "count": (wrappedValue: count?.encodeToJSON(), isExplode: true),
            "searchTarget": (wrappedValue: searchTarget?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "excludeAlreadyWatched": (wrappedValue: excludeAlreadyWatched?.encodeToJSON(), isExplode: true),
            "startDate": (wrappedValue: startDate?.encodeToJSON(), isExplode: true),
            "endDate": (wrappedValue: endDate?.encodeToJSON(), isExplode: true),
            "originallyPublishedStartDate": (wrappedValue: originallyPublishedStartDate?.encodeToJSON(), isExplode: true),
            "originallyPublishedEndDate": (wrappedValue: originallyPublishedEndDate?.encodeToJSON(), isExplode: true),
            "durationMin": (wrappedValue: durationMin?.encodeToJSON(), isExplode: true),
            "durationMax": (wrappedValue: durationMax?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VideoListResponse>.Type = OpenAPIClientAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: false)
    }
}
